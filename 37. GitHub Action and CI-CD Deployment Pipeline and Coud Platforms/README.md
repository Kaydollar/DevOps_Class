# GitHub Action and CI/CD Course: Deployment Pipelines and Cloud Platforms.

## Introduction to GitHub Actions Course: Deployment and Cloud Integration.

### Lesson 1: Introduction to Deployment Pipeline

- Objectives:
    - Define and understand the stages of delpoyment pipeline.
    - Learn about different deployment strategies.

### Lesson Details:
1. Defining deployment Stages
- **Development:** Writing a testing code in a local environment
- **Integration:** Merging Code changes to a shared branch
- **Testing:** Running automated tests to ensure code Quality
- **Staging:** Deploying code to a production-like environment for final testing.
- **Production:** Releasing the final version of your code to the end user.

### Understanding Delpoyment Strategies:

- **Blue-Green Deployment:** Running two production environment, only one which serves end users at any time.
- **Canary Releases:** Rolling out changes to a small subset of users before full deployment.
- **Rolling Deployment:** Gradually replacing instances of the previous version of an application with the new version. 

### Lesson 2: Automated Relases and versioning

**Objectives**
- Automate Versioning in the CI/CD Process.
- Create and manage software releases.

**Automating Versioning in CI/CD:**
1. Semantic Versioning:
- Use semantic versioning (SemVer) for your software. It uses a three-part version number, for example, `MAJOR.MINOR.PATCH`
- Resources: [Sematic Versioning](https://semver.org/) 

2. Automated Versioning with gitHub Actions:
- Implement Automated Versioning using GitHub Actions to Increment version numbers automatically based on code changes.

Example Snippet for a Versioning Script in GitHubActions:
```bash
name: Bump version and tag

on:
  push:
    branches:
      - main

jobs:
  build:
    name: Create Tag
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        # Checks out the code so version bump can work on repo

      - name: Bump version and push tag
        uses: anothrNick/github-tag-action@1.66.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEFAULT_BUMP: patch
          WITH_V: true
        # DEFAULT_BUMP options: patch, minor, major, or false (if you want only manual bumping).
        # WITH_V adds a "v" prefix to the tag, like v1.2.3 (recommended for semantic versioning)
```
This action will automatically increase the patch version and create a new tag each time changes are pushed to the main branch.

### Ceating and Managing Releases:
1. Automating releases with GitHub Actions:
- Setup GitHub Action to create a new releases whenever a new tag is pushed to the Repository.

**Example snippet to create a release**
```bash
on:
  push:
    tags:
      - '*'  # Triggers on all tags

jobs:
  build:
    name: Create Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        # Checks out the code corresponding to the tag.

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false
```
The `actions/create-release@v1` action is used to create a release on GitHub. It uses the tag that triggered the workflow to name and label the release. 

### Troubleshooting and Additional Resources:

- For troubleshooting GitHub Actions, the GitHub Actions Documentation is an invaluable resource.

- To resolve issues related to specific actions used in your workflow, refer to their respective repositories on GitHub or their documentation.

- For general questions and community support, the GitHub Community Forum can be a great place to seek help.

- Remember, reading through the logs generated by GitHub Actions can provide insights into what might be going wrong with your workflows.

### Lesson 3: Deploying to Cloud Platforms

**Objectives:**
- Deploy applications to popular cloud platforms using GitHub Actions.

- Configure deployment environments.

### Lesson Details:
- Detailed Guide: Deploying Applications to Cloud Platforms with GitHub Actions

- For beginners completely new to GitHub Actions and cloud deployment, it's essential to understand the process step-by-step. Here's a detailed breakdown of deploying applications to cloud platforms like AWS, Azure, or Google Cloud Platform using GitHub Actions:

### Step 1: Choose a Cloud Platform.

- Decide on the Cloud Platform based on your Project requirement. Each Platform (AWS, AZURE, GOOGLE CLOUD) has its own set of services and Pricing Models.
- AWS: [Amazon Web Services](https://aws.amazon.com/)
- Azure: [Microsoft Azure](https://azure.microsoft.com/en-us/)
- GCP: [Google Cloud Platform](https://cloud.google.com/)

### Step 2: Set-UP GitHub Action for Deployment.
1. Creating the Workflow File:
- Workflow files are YAML files storage in your repository's `.github/workflows` directory.
- Start by creating a file e.g, `deploy-to-aws.yml` in this directory.
2. Defining the Workflow
- A workflow is defined with a series of steps that run on specified events.

***Example of AWS Deployment***
```bash
name: Deploy to AWS
on:
  push:
    branches:
      - main
  # Triggers on push to 'main' branch.

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2
        # Reads AWS keys from GitHub repository secrets.

      - name: Deploy to AWS
        run: |
          echo "Starting deployment..."
          # Example for Elastic Beanstalk:
          zip -r app.zip .
          aws elasticbeanstalk create-application-version \
            --application-name "my-node-app" \
            --version-label $GITHUB_SHA \
            --source-bundle S3Bucket="my-bucket",S3Key="app-$GITHUB_SHA.zip"
          aws elasticbeanstalk update-environment \
            --environment-name "my-env" \
            --version-label $GITHUB_SHA
```
This workflow deploys your application to AWS when changes are pushed to the main branch.

### Example of Azure Deploymnet
```bash
name: CI/CD to Azure App Service

on:
  push:
    branches:
      - main  # deploys on push to main branch

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install dependencies
        run: npm ci

      - name: Lint Code
        run: npx eslint .

      - name: Run Tests
        run: npm test

      - name: Build app (optional)
        run: npm run build
        # Use only if you have a build step, e.g. React front-end or TypeScript

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ secrets.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_PUBLISH_PROFILE }}
          package: .
``` 
### Example GCP Deployment:
```bash
name: Deploy to GCP Cloud Run

on:
  push:
    branches:
      - main

jobs:
  deploy:
    name: Build and Deploy to Cloud Run
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${REGION}-docker.pkg.dev
        env:
          REGION: ${{ secrets.GCP_REGION }}

      - name: Build and push Docker image
        run: |
          IMAGE=${{ secrets.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/my-repo/${{ secrets.GCP_RUN_SERVICE }}:$GITHUB_SHA
          docker build -t $IMAGE .
          docker push $IMAGE

      - name: Deploy to Cloud Run
        run: |
          IMAGE=${{ secrets.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/my-repo/${{ secrets.GCP_RUN_SERVICE }}:$GITHUB_SHA
          gcloud run deploy ${{ secrets.GCP_RUN_SERVICE }} \
            --image $IMAGE \
            --region ${{ secrets.GCP_REGION }} \
            --platform managed \
            --allow-unauthenticated
```

### Step 3: Configuring Deployment Environments
1. Setting UP Environment VAriables and Secrets
- Store sensitive information like API Keys and Access tokens as [GITHUB SECRETS](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/using-secrets-in-github-actions)
- Use Environment Variables for non-sensitive configuratiom. 
2. Environment-Specific Workflow:
- Tailor your workflow for different environments (development, staging, production) by using conditions or different workflow files.

Additional Resources:
• GitHub Actions Documentation: For a comprehensive understanding, refer to the [official documentation.](https://docs.github.com/en/actions)

AWS GitHub Actions: Learn more about the [AWS actions available on GitHub.](https://github.com/aws-actions)

Azure GitHub Actions: Check out [Azure actions.](https://github.com/Azure/actions)
Google Cloud GitHub Actions: Explore [Google Cloud actions.](https://github.com/google-github-actions)

### Troubleshooting
- Review action logs in GitHub for errors during execution.
- Ensure that your cloud platform credentials are correctly set up in GitHub Secrets.
- Validate your YAML file for syntax errors using online validators like [YAML Lint.](https://www.yamllint.com/)